/*
 * MikroClaw - jsmn JSON Parser Implementation
 */

#include "jsmn.h"

void jsmn_init(jsmn_parser *parser) {
    parser->pos = 0;
    parser->toknext = 0;
    parser->toksuper = -1;
}

static int jsmn_alloc_token(jsmn_parser *parser, jsmntok_t *tokens,
                            size_t num_tokens) {
    (void)tokens;
    if (parser->toknext >= num_tokens) {
        return -1;
    }
    return parser->toknext++;
}

static void jsmn_fill_token(jsmntok_t *token, jsmntype_t type,
                            int start, int end) {
    token->type = type;
    token->start = start;
    token->end = end;
    token->size = 0;
}

static int jsmn_parse_string(jsmn_parser *parser, const char *js,
                              size_t len, jsmntok_t *tokens, size_t num_tokens) {
    int start = parser->pos;
    parser->pos++;
    
    for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
        char c = js[parser->pos];
        
        if (c == '"') {
            if (tokens == NULL) {
                return 0;
            }
            int i = jsmn_alloc_token(parser, tokens, num_tokens);
            if (i < 0) return i;
            jsmn_fill_token(&tokens[i], JSMN_STRING, start + 1, parser->pos);
            return 0;
        }
        
        if (c == '\\' && parser->pos + 1 < len) {
            parser->pos++;
        }
    }
    
    return JSMN_ERROR_PART;
}

static int jsmn_parse_primitive(jsmn_parser *parser, const char *js,
                                 size_t len, jsmntok_t *tokens, size_t num_tokens) {
    int start = parser->pos;
    
    for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
        char c = js[parser->pos];
        switch (c) {
            case ':':
            case ',':
            case ']':
            case '}':
            case ' ':
            case '\t':
            case '\r':
            case '\n':
                goto found;
        }
        if (c < 32 || c >= 127) {
            parser->pos = start;
            return JSMN_ERROR_INVAL;
        }
    }

found:
    if (tokens == NULL) {
        return 0;
    }
    
    int i = jsmn_alloc_token(parser, tokens, num_tokens);
    if (i < 0) return i;
    jsmn_fill_token(&tokens[i], JSMN_PRIMITIVE, start, parser->pos);
    parser->pos--;
    return 0;
}

int jsmn_parse(jsmn_parser *parser, const char *js, size_t len,
               jsmntok_t *tokens, size_t num_tokens) {
    int r;
    int i;
    int count = parser->toknext;
    
    for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
        char c = js[parser->pos];
        jsmntype_t type;
        
        switch (c) {
            case '{':
            case '[':
                count++;
                if (tokens == NULL) break;
                type = (c == '{' ? JSMN_OBJECT : JSMN_ARRAY);
                i = jsmn_alloc_token(parser, tokens, num_tokens);
                if (i < 0) return i;
                if (parser->toksuper != -1) {
                    tokens[parser->toksuper].size++;
                }
                tokens[i].type = type;
                tokens[i].start = parser->pos;
                parser->toksuper = i;
                break;
                
            case '}':
            case ']':
                if (tokens == NULL) break;
                type = (c == '}' ? JSMN_OBJECT : JSMN_ARRAY);
                for (i = parser->toknext - 1; i >= 0; i--) {
                    if (tokens[i].start != -1 && tokens[i].end == -1) {
                        if (tokens[i].type != type) return JSMN_ERROR_INVAL;
                        parser->toksuper = -1;
                        tokens[i].end = parser->pos + 1;
                        break;
                    }
                }
                break;
                
            case '"':
                r = jsmn_parse_string(parser, js, len, tokens, num_tokens);
                if (r < 0) return r;
                count++;
                if (parser->toksuper != -1 && tokens != NULL) {
                    tokens[parser->toksuper].size++;
                }
                break;
                
            case '\t':
            case '\r':
            case '\n':
            case ' ':
                break;
                
            case ':':
                parser->toksuper = parser->toknext - 1;
                break;
                
            case ',':
                if (tokens != NULL && parser->toksuper != -1) {
                    int super = parser->toksuper;
                    while (super != -1 && tokens[super].type != JSMN_OBJECT && tokens[super].type != JSMN_ARRAY) {
                        super--;
                    }
                    parser->toksuper = super;
                }
                break;
                
            default:
                r = jsmn_parse_primitive(parser, js, len, tokens, num_tokens);
                if (r < 0) return r;
                count++;
                if (parser->toksuper != -1 && tokens != NULL) {
                    tokens[parser->toksuper].size++;
                }
                break;
        }
    }
    
    if (tokens != NULL) {
        for (i = parser->toknext - 1; i >= 0; i--) {
            if (tokens[i].start != -1 && tokens[i].end == -1) {
                return JSMN_ERROR_PART;
            }
        }
    }
    
    return count;
}
